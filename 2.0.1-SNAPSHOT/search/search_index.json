{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 ScreamingLib is a multiplatform library for creating Minecraft plugins/extensions. Module list \u00b6 Modules for servers \u00b6 Core (server) Tasker Event Hologram Healthindicator Lang NPC Packets Placeholders Command Scoreboards and sidebars Clickable signs Modules for proxy \u00b6 Core (proxy) Tasker Event Lang Command Compiling \u00b6 Requirements \u00b6 JDK 11 and higher Internet connection Clone the repo and run ./gradlew screamCompile . Binaries for each module will be present in the build/libs folder of each subproject and also in your local maven repository.","title":"Home"},{"location":"#home","text":"ScreamingLib is a multiplatform library for creating Minecraft plugins/extensions.","title":"Home"},{"location":"#module-list","text":"","title":"Module list"},{"location":"#modules-for-servers","text":"Core (server) Tasker Event Hologram Healthindicator Lang NPC Packets Placeholders Command Scoreboards and sidebars Clickable signs","title":"Modules for servers"},{"location":"#modules-for-proxy","text":"Core (proxy) Tasker Event Lang Command","title":"Modules for proxy"},{"location":"#compiling","text":"","title":"Compiling"},{"location":"#requirements","text":"JDK 11 and higher Internet connection Clone the repo and run ./gradlew screamCompile . Binaries for each module will be present in the build/libs folder of each subproject and also in your local maven repository.","title":"Requirements"},{"location":"modules/command/","text":"Command \u00b6 Module required for creating multi-platform commands. Features \u00b6 Cloud Command Framework integration Usage \u00b6 Supported platforms are: bukkit, bungee, minestom, sponge, velocity Maven \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> command-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> <!-- Optional, but recommended (change version to the latest if necessary) --> <!-- https://mvnrepository.com/artifact/cloud.commandframework/cloud-minecraft-extras --> <dependency> <groupId> cloud.commandframework </groupId> <artifactId> cloud-minecraft-extras </artifactId> <version> 1.5.0 </version> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package --> Gradle \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:command-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' // Optional, but recommended (change the version to the latest if necessary) // https://mvnrepository.com/artifact/cloud.commandframework/cloud-minecraft-extras implementation 'cloud.commandframework:cloud-minecraft-extras:1.5.0' } Examples \u00b6 Creating commands with Cloud \u00b6 Command service \u00b6 Let's start with creating a service that will construct all of our commands (feel free to copy paste the snippet). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Service ( dependsOn = { CloudConstructor . class }) public final class CommandService { @Provider ( level = Provider . Level . POST_ENABLE ) public static CommandManager < CommandSenderWrapper > provideCommandManager () { try { final CommandManager < CommandSenderWrapper > manager = CloudConstructor . construct ( CommandExecutionCoordinator . simpleCoordinator ()); // provides a central place for handling common command usage errors // remove this part if you don't have the cloud-minecraft-extras module new MinecraftExceptionHandler < CommandSenderWrapper > () . withDefaultHandlers () . withHandler ( MinecraftExceptionHandler . ExceptionType . NO_PERMISSION , ( senderWrapper , e ) -> // Component from Adventure Component . text ( \"Insufficient permissions!\" ) ) . withHandler ( MinecraftExceptionHandler . ExceptionType . INVALID_SYNTAX , ( senderWrapper , e ) -> // Component from Adventure Component . text ( \"Invalid syntax!\" ) ) . apply ( manager , s -> s ); return manager ; } catch ( Exception e ) { e . printStackTrace (); } return null ; } } Base command class \u00b6 Then, create an abstract class that will be extended by the command classes (feel free to copy paste the snippet). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @ServiceDependencies ( dependsOn = { CommandService . class // the command service class you created in the last step }) public abstract class BaseCommand { protected final @NonNull String name ; protected final @Nullable Permission permission ; protected final boolean allowConsole ; public BaseCommand ( String name , Permission permission , boolean allowConsole ) { this . name = name ; this . permission = permission ; this . allowConsole = allowConsole ; } public @NonNull String getName () { return name ; } public @Nullable Permission getPermission () { return permission ; } public boolean isConsoleAllowed () { return allowConsole ; } protected abstract void construct ( Command . Builder < CommandSenderWrapper > commandSenderWrapperBuilder , CommandManager < CommandSenderWrapper > manager ); @OnPostEnable public void construct ( @ProvidedBy ( CommandService . class ) CommandManager < CommandSenderWrapper > manager ) { // all commands will have the same root, e.g. /someplugin <command name> Command . Builder < CommandSenderWrapper > builder = manager . commandBuilder ( \"someplugin\" ) . literal ( name ); // or you can have separated commands // Command.Builder<CommandSenderWrapper> builder = manager.commandBuilder(name); // checks for permissions if ( permission != null ) { builder = builder . permission ( PredicatePermission . of ( SimpleCloudKey . of ( name ), perm -> perm . getType () == CommandSenderWrapper . Type . CONSOLE || permission . hasPermission ( perm ) ) ); } // sender will be directly PlayerWrapper, if console is not allowed if ( ! allowConsole ) { builder = builder . senderType ( PlayerWrapper . class ); } construct ( builder , manager ); } } Command implementation \u00b6 Now let's actually implement the command. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Service public class ExampleCommand extends BaseCommand { // extend the base command class that we created in the last step public BanCommand () { // command name, command permission (can be null for no permission), is console allowed? super ( \"examplecommand\" , null , true ); } @Override protected void construct ( Command . Builder < CommandSenderWrapper > commandSenderWrapperBuilder , CommandManager < CommandSenderWrapper > manager ) { manager . command ( commandSenderWrapperBuilder // PlayerWrapper argument . argument ( manager . argumentBuilder ( String . class , \"player\" ) . withSuggestionsProvider (( c , s ) -> Server . getConnectedPlayers (). stream (). map ( PlayerWrapper :: getName ). toList () ) ) . handler ( commandContext -> { final Optional < PlayerWrapper > player = PlayerMapper . getPlayer (( String ) commandContext . get ( \"player\" )); if ( player . isEmpty ()) { commandContext . getSender (). sendMessage ( \"Invalid player specified!\" ); return ; } final String senderName = ( commandContext . getSender (). getType () == CommandSenderWrapper . Type . CONSOLE ) ? \"CONSOLE\" : commandContext . getSender (). as ( PlayerWrapper . class ). getName (); player . orElseThrow (). sendMessage ( \"Hello from \" + senderName ); }) ); } } Now register the command implementation class in your plugin's @Init annotation, and you're done! You've just made yourself a command in the /someplugin examplecommand <player> format.","title":"Command"},{"location":"modules/command/#command","text":"Module required for creating multi-platform commands.","title":"Command"},{"location":"modules/command/#features","text":"Cloud Command Framework integration","title":"Features"},{"location":"modules/command/#usage","text":"Supported platforms are: bukkit, bungee, minestom, sponge, velocity","title":"Usage"},{"location":"modules/command/#maven","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> command-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> <!-- Optional, but recommended (change version to the latest if necessary) --> <!-- https://mvnrepository.com/artifact/cloud.commandframework/cloud-minecraft-extras --> <dependency> <groupId> cloud.commandframework </groupId> <artifactId> cloud-minecraft-extras </artifactId> <version> 1.5.0 </version> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package -->","title":"Maven"},{"location":"modules/command/#gradle","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:command-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' // Optional, but recommended (change the version to the latest if necessary) // https://mvnrepository.com/artifact/cloud.commandframework/cloud-minecraft-extras implementation 'cloud.commandframework:cloud-minecraft-extras:1.5.0' }","title":"Gradle"},{"location":"modules/command/#examples","text":"","title":"Examples"},{"location":"modules/command/#creating-commands-with-cloud","text":"","title":"Creating commands with Cloud"},{"location":"modules/command/#command-service","text":"Let's start with creating a service that will construct all of our commands (feel free to copy paste the snippet). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Service ( dependsOn = { CloudConstructor . class }) public final class CommandService { @Provider ( level = Provider . Level . POST_ENABLE ) public static CommandManager < CommandSenderWrapper > provideCommandManager () { try { final CommandManager < CommandSenderWrapper > manager = CloudConstructor . construct ( CommandExecutionCoordinator . simpleCoordinator ()); // provides a central place for handling common command usage errors // remove this part if you don't have the cloud-minecraft-extras module new MinecraftExceptionHandler < CommandSenderWrapper > () . withDefaultHandlers () . withHandler ( MinecraftExceptionHandler . ExceptionType . NO_PERMISSION , ( senderWrapper , e ) -> // Component from Adventure Component . text ( \"Insufficient permissions!\" ) ) . withHandler ( MinecraftExceptionHandler . ExceptionType . INVALID_SYNTAX , ( senderWrapper , e ) -> // Component from Adventure Component . text ( \"Invalid syntax!\" ) ) . apply ( manager , s -> s ); return manager ; } catch ( Exception e ) { e . printStackTrace (); } return null ; } }","title":"Command service"},{"location":"modules/command/#base-command-class","text":"Then, create an abstract class that will be extended by the command classes (feel free to copy paste the snippet). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @ServiceDependencies ( dependsOn = { CommandService . class // the command service class you created in the last step }) public abstract class BaseCommand { protected final @NonNull String name ; protected final @Nullable Permission permission ; protected final boolean allowConsole ; public BaseCommand ( String name , Permission permission , boolean allowConsole ) { this . name = name ; this . permission = permission ; this . allowConsole = allowConsole ; } public @NonNull String getName () { return name ; } public @Nullable Permission getPermission () { return permission ; } public boolean isConsoleAllowed () { return allowConsole ; } protected abstract void construct ( Command . Builder < CommandSenderWrapper > commandSenderWrapperBuilder , CommandManager < CommandSenderWrapper > manager ); @OnPostEnable public void construct ( @ProvidedBy ( CommandService . class ) CommandManager < CommandSenderWrapper > manager ) { // all commands will have the same root, e.g. /someplugin <command name> Command . Builder < CommandSenderWrapper > builder = manager . commandBuilder ( \"someplugin\" ) . literal ( name ); // or you can have separated commands // Command.Builder<CommandSenderWrapper> builder = manager.commandBuilder(name); // checks for permissions if ( permission != null ) { builder = builder . permission ( PredicatePermission . of ( SimpleCloudKey . of ( name ), perm -> perm . getType () == CommandSenderWrapper . Type . CONSOLE || permission . hasPermission ( perm ) ) ); } // sender will be directly PlayerWrapper, if console is not allowed if ( ! allowConsole ) { builder = builder . senderType ( PlayerWrapper . class ); } construct ( builder , manager ); } }","title":"Base command class"},{"location":"modules/command/#command-implementation","text":"Now let's actually implement the command. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Service public class ExampleCommand extends BaseCommand { // extend the base command class that we created in the last step public BanCommand () { // command name, command permission (can be null for no permission), is console allowed? super ( \"examplecommand\" , null , true ); } @Override protected void construct ( Command . Builder < CommandSenderWrapper > commandSenderWrapperBuilder , CommandManager < CommandSenderWrapper > manager ) { manager . command ( commandSenderWrapperBuilder // PlayerWrapper argument . argument ( manager . argumentBuilder ( String . class , \"player\" ) . withSuggestionsProvider (( c , s ) -> Server . getConnectedPlayers (). stream (). map ( PlayerWrapper :: getName ). toList () ) ) . handler ( commandContext -> { final Optional < PlayerWrapper > player = PlayerMapper . getPlayer (( String ) commandContext . get ( \"player\" )); if ( player . isEmpty ()) { commandContext . getSender (). sendMessage ( \"Invalid player specified!\" ); return ; } final String senderName = ( commandContext . getSender (). getType () == CommandSenderWrapper . Type . CONSOLE ) ? \"CONSOLE\" : commandContext . getSender (). as ( PlayerWrapper . class ). getName (); player . orElseThrow (). sendMessage ( \"Hello from \" + senderName ); }) ); } } Now register the command implementation class in your plugin's @Init annotation, and you're done! You've just made yourself a command in the /someplugin examplecommand <player> format.","title":"Command implementation"},{"location":"modules/core/","text":"Core \u00b6 Base module required for pretty much everything in SLib. Contains the base features for working with the server, such as the item API, block API, entities API and more. All other modules require this module to be present. Platform support \u00b6 Minecraft: Java Edition <1.9.4 1.9.4 1.10.x 1.11.x 1.12.x 1.13.x 1.14.x 1.15.x 1.16.x 1.17.x Spigot / Paper (and forks) No Yes Yes Yes Yes Yes Yes Yes Yes Yes Glowstone No ? ? ? ? ? MohistMC (and similar) No ? ? ? Minestom No Planned Sponge API 8+ Planned Planned ? = the version may be supported, but the current state is unknown Empty field = there's no such version of the specific platform Support for the Bedrock Edition is also planned, but not anytime soon. Minecraft: Bedrock Edition Latest Nukkit Planned Cloudburst Planned Usage \u00b6 Supported platforms are: bukkit, minestom, sponge Maven \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> core-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package --> Gradle \u00b6 1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:core-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' } Comparison to the Bukkit API \u00b6 Bukkit API class SLib class Player PlayerWrapper HumanEntity EntityHuman LivingEntity EntityLiving Projectile EntityProjectile Item EntityItem ExperienceOrb EntityExperience LightningStrike EntityLightning Firework EntityFirework Entity EntityBasic World WorldHolder Location LocationHolder Block BlockHolder Material ItemTypeHolder (for item materials), BlockTypeHolder (for block materials) Server Server ItemStack Item Services \u00b6 Services are classes with the @Service annotation, specified in the @Init annotation on the main plugin class. They are initialized when the plugin starts to load. It is possible to retrieve the service class instances with the ServiceManager class ( ServiceManager#get(Class<?>) ). Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Service ( dependsOn = { SomeExampleServiceThatThisDependsOn . class }, loadAfter = { SomeExampleServiceThatWillBeLoadedBeforeThis . class }) public class ExampleService { @OnPostConstruct public void onConstruct () { // Service construction logic } @OnEnable public void enable () { // Service enable logic } @OnDisable public void disable () { // Service disable logic (plugin is disabling) } } Annotations \u00b6 @Service(dependsOn = {}, loadAfter = {}) - Marks the annotated class as a service. Service classes specified in the dependsOn field are loaded before initializing the annotated class, while service classes specified in the loadAfter field are loaded after initializing the annotated class. @OnPostConstruct - Marks the annotated method to run directly after the service class is constructed. @OnEnable - Marks the annotated method to run after the service class is initialized. @OnDisable - Marks the annotated method to run after the service class is being disabled (plugin is disabling). @Init(platforms = {}, services = {}) (plugin class only) - Defines service classes that should be initialized when the plugin is loading (order sensitive). In the platforms field, you can specify platforms that the service classes in the annotation will be initialized on (array of PlatformType , can be left out).","title":"Core"},{"location":"modules/core/#core","text":"Base module required for pretty much everything in SLib. Contains the base features for working with the server, such as the item API, block API, entities API and more. All other modules require this module to be present.","title":"Core"},{"location":"modules/core/#platform-support","text":"Minecraft: Java Edition <1.9.4 1.9.4 1.10.x 1.11.x 1.12.x 1.13.x 1.14.x 1.15.x 1.16.x 1.17.x Spigot / Paper (and forks) No Yes Yes Yes Yes Yes Yes Yes Yes Yes Glowstone No ? ? ? ? ? MohistMC (and similar) No ? ? ? Minestom No Planned Sponge API 8+ Planned Planned ? = the version may be supported, but the current state is unknown Empty field = there's no such version of the specific platform Support for the Bedrock Edition is also planned, but not anytime soon. Minecraft: Bedrock Edition Latest Nukkit Planned Cloudburst Planned","title":"Platform support"},{"location":"modules/core/#usage","text":"Supported platforms are: bukkit, minestom, sponge","title":"Usage"},{"location":"modules/core/#maven","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> core-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package -->","title":"Maven"},{"location":"modules/core/#gradle","text":"1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:core-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' }","title":"Gradle"},{"location":"modules/core/#comparison-to-the-bukkit-api","text":"Bukkit API class SLib class Player PlayerWrapper HumanEntity EntityHuman LivingEntity EntityLiving Projectile EntityProjectile Item EntityItem ExperienceOrb EntityExperience LightningStrike EntityLightning Firework EntityFirework Entity EntityBasic World WorldHolder Location LocationHolder Block BlockHolder Material ItemTypeHolder (for item materials), BlockTypeHolder (for block materials) Server Server ItemStack Item","title":"Comparison to the Bukkit API"},{"location":"modules/core/#services","text":"Services are classes with the @Service annotation, specified in the @Init annotation on the main plugin class. They are initialized when the plugin starts to load. It is possible to retrieve the service class instances with the ServiceManager class ( ServiceManager#get(Class<?>) ). Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Service ( dependsOn = { SomeExampleServiceThatThisDependsOn . class }, loadAfter = { SomeExampleServiceThatWillBeLoadedBeforeThis . class }) public class ExampleService { @OnPostConstruct public void onConstruct () { // Service construction logic } @OnEnable public void enable () { // Service enable logic } @OnDisable public void disable () { // Service disable logic (plugin is disabling) } }","title":"Services"},{"location":"modules/core/#annotations","text":"@Service(dependsOn = {}, loadAfter = {}) - Marks the annotated class as a service. Service classes specified in the dependsOn field are loaded before initializing the annotated class, while service classes specified in the loadAfter field are loaded after initializing the annotated class. @OnPostConstruct - Marks the annotated method to run directly after the service class is constructed. @OnEnable - Marks the annotated method to run after the service class is initialized. @OnDisable - Marks the annotated method to run after the service class is being disabled (plugin is disabling). @Init(platforms = {}, services = {}) (plugin class only) - Defines service classes that should be initialized when the plugin is loading (order sensitive). In the platforms field, you can specify platforms that the service classes in the annotation will be initialized on (array of PlatformType , can be left out).","title":"Annotations"},{"location":"modules/event/","text":"Event \u00b6 Module required for handling game events. Features \u00b6 Event priorities Ignoring cancellation Usage \u00b6 Supported platforms are: bukkit, sponge, bungee, velocity Maven \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> event-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package --> Gradle \u00b6 1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:event-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' } Examples \u00b6 Handling game events \u00b6 First of all, start by making a simple service class, like this: 1 2 3 4 @Service public class ExampleService { // Service class } Then create a new public method that returns void, has an event parameter and annotate it with @OnEvent . It is possible to specify the priority field and the ignoreCancelled field in the annotation. 1 2 3 4 5 6 7 @Service public class ExampleService { @OnEvent ( priority = EventPriority . HIGHEST , ignoreCancelled = true ) public void onPlayerInteract ( SPlayerInteractEvent event ) { // Event handling logic } } Then register the service class in the @Init annotation on the main plugin class, and you're done!","title":"Event"},{"location":"modules/event/#event","text":"Module required for handling game events.","title":"Event"},{"location":"modules/event/#features","text":"Event priorities Ignoring cancellation","title":"Features"},{"location":"modules/event/#usage","text":"Supported platforms are: bukkit, sponge, bungee, velocity","title":"Usage"},{"location":"modules/event/#maven","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> event-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package -->","title":"Maven"},{"location":"modules/event/#gradle","text":"1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:event-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' }","title":"Gradle"},{"location":"modules/event/#examples","text":"","title":"Examples"},{"location":"modules/event/#handling-game-events","text":"First of all, start by making a simple service class, like this: 1 2 3 4 @Service public class ExampleService { // Service class } Then create a new public method that returns void, has an event parameter and annotate it with @OnEvent . It is possible to specify the priority field and the ignoreCancelled field in the annotation. 1 2 3 4 5 6 7 @Service public class ExampleService { @OnEvent ( priority = EventPriority . HIGHEST , ignoreCancelled = true ) public void onPlayerInteract ( SPlayerInteractEvent event ) { // Event handling logic } } Then register the service class in the @Init annotation on the main plugin class, and you're done!","title":"Handling game events"},{"location":"modules/npc/","text":"NPC \u00b6 Module for creating multi-platform NPC entities. Features \u00b6 Multiline names Skins Head following player Usage \u00b6 Supported platforms are the same as the packets module, because this module doesn't have any platform specific code. Maven \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> npc-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package --> Gradle \u00b6 1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:npc-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' } Examples \u00b6 Creating your first NPC \u00b6 Start by spawning the NPC on a specified location, like this: 1 final NPC npc = NPC . of ( yourLocation ); Now let's set a nice skin for the NPC. You will need the skin value and the skin signature, both of these you can get from Mojang's session server. I'll use Misat's skin in this example. 1 2 3 4 5 6 7 8 9 10 11 12 13 // https://sessionserver.mojang.com/session/minecraft/profile/<player uuid>?unsigned=false // misat's player profile // https://sessionserver.mojang.com/session/minecraft/profile/4ffbed72-702f-4fea-abde-22c5e1078abb?unsigned=false final NPC npc = NPC . of ( yourLocation ) . setSkin ( new NPCSkin ( // value \"ewogICJ0aW1lc3RhbXAiIDogMTYzNDQ2MDM3ODUxNywKICAicHJvZmlsZUlkIiA6ICI0ZmZiZWQ3MjcwMmY0ZmVhYWJkZTIyYzVlMTA3OGFiYiIsCiAgInByb2ZpbGVOYW1lIiA6ICJNaXNhdDExIiwKICAic2lnbmF0dXJlUmVxdWlyZWQiIDogdHJ1ZSwKICAidGV4dHVyZXMiIDogewogICAgIlNLSU4iIDogewogICAgICAidXJsIiA6ICJodHRwOi8vdGV4dHVyZXMubWluZWNyYWZ0Lm5ldC90ZXh0dXJlLzRlYTFmMWY1NmQ4NThhMTEwMjNlYWQ3NjhkMGE4NWQ2MDEzM2E3MDBkMzYyN2U1YjA1YzAwZmUzYmJmZWU5YzAiCiAgICB9LAogICAgIkNBUEUiIDogewogICAgICAidXJsIiA6ICJodHRwOi8vdGV4dHVyZXMubWluZWNyYWZ0Lm5ldC90ZXh0dXJlLzIzNDBjMGUwM2RkMjRhMTFiMTVhOGIzM2MyYTdlOWUzMmFiYjIwNTFiMjQ4MWQwYmE3ZGVmZDYzNWNhN2E5MzMiCiAgICB9CiAgfQp9\" , // signature \"gaXuCCGyQ6465FS9kC0ylODMSV9aobFTqZuHsJlJhD1JbRQgYXzo5NdCHkKhu1GetmcDwueFYDRCN/KEMGCe79GOFgycdeOBcAxdiXRZg7mH2o8QR/5sIaD7yhrUKe+2Ji866j2gkPF7n4qWRSR5N+n66DxkO6S+/cb6J5CGYDUGZ6ywYKI2NkSg5Qn0O3bIvTbybl5n+y9Fcal4qyMOMBEpUSeNfkcmOn7SWawvXFY6o/1stHwVdNthF6dilsJSuNcMTnvsZ0vfFv9nzjf/Z1QF6aNF+BmucgTKT2idEOrh4hXIcRS+wrrC/jFGVXxcsSAkCS9cx7T5Nw2n5RNQMFFvJDkrHRLewagjD09J7C6E9LFBdWNWCxyWPueMN0kWdufsaFwAWCaOAdX2bh4E93Z2Y5dap+8gRiJAQBh4Z0QPuB97WpN2aptSBC6+q3jgmOd1LwefdHIm4sPktewdxTDewRULVY3ERTfxZB8WmX3hDHmHIlGufOhrDE7KI44BmnveQmRDFzMea+XUhQp3VXgnCLPf7W7rQ3+rluj1K9cAds/KPQIv0OjM+xlhZVRHWmcuISv7nEzoImblUc4WcUmhr7YxfZGrXLejc58/Dro95XK+AmNYmjcnZZry4yLmZEuba5UIYHEd9fdRSPwi/h3PyOBHUo2JMvc+TsgRaUU=\" ) ); I think that NPC's looking into your soul are not creepy at all, so let's make the NPC look at players and let's give it a name. 1 2 3 4 5 final NPC npc = ...; // you can totally do this in the npc builder, i chose not to, because i didn't want to copy the huge block of skin values npc . setShouldLookAtPlayer ( true ); // requires a List<Component> to allow for multiline names npc . setDisplayName ( Arrays . asList ( Component . text ( \"Misat11\" ))); And you've made yourself a fresh new NPC!","title":"NPC"},{"location":"modules/npc/#npc","text":"Module for creating multi-platform NPC entities.","title":"NPC"},{"location":"modules/npc/#features","text":"Multiline names Skins Head following player","title":"Features"},{"location":"modules/npc/#usage","text":"Supported platforms are the same as the packets module, because this module doesn't have any platform specific code.","title":"Usage"},{"location":"modules/npc/#maven","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> npc-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package -->","title":"Maven"},{"location":"modules/npc/#gradle","text":"1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:npc-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' }","title":"Gradle"},{"location":"modules/npc/#examples","text":"","title":"Examples"},{"location":"modules/npc/#creating-your-first-npc","text":"Start by spawning the NPC on a specified location, like this: 1 final NPC npc = NPC . of ( yourLocation ); Now let's set a nice skin for the NPC. You will need the skin value and the skin signature, both of these you can get from Mojang's session server. I'll use Misat's skin in this example. 1 2 3 4 5 6 7 8 9 10 11 12 13 // https://sessionserver.mojang.com/session/minecraft/profile/<player uuid>?unsigned=false // misat's player profile // https://sessionserver.mojang.com/session/minecraft/profile/4ffbed72-702f-4fea-abde-22c5e1078abb?unsigned=false final NPC npc = NPC . of ( yourLocation ) . setSkin ( new NPCSkin ( // value \"ewogICJ0aW1lc3RhbXAiIDogMTYzNDQ2MDM3ODUxNywKICAicHJvZmlsZUlkIiA6ICI0ZmZiZWQ3MjcwMmY0ZmVhYWJkZTIyYzVlMTA3OGFiYiIsCiAgInByb2ZpbGVOYW1lIiA6ICJNaXNhdDExIiwKICAic2lnbmF0dXJlUmVxdWlyZWQiIDogdHJ1ZSwKICAidGV4dHVyZXMiIDogewogICAgIlNLSU4iIDogewogICAgICAidXJsIiA6ICJodHRwOi8vdGV4dHVyZXMubWluZWNyYWZ0Lm5ldC90ZXh0dXJlLzRlYTFmMWY1NmQ4NThhMTEwMjNlYWQ3NjhkMGE4NWQ2MDEzM2E3MDBkMzYyN2U1YjA1YzAwZmUzYmJmZWU5YzAiCiAgICB9LAogICAgIkNBUEUiIDogewogICAgICAidXJsIiA6ICJodHRwOi8vdGV4dHVyZXMubWluZWNyYWZ0Lm5ldC90ZXh0dXJlLzIzNDBjMGUwM2RkMjRhMTFiMTVhOGIzM2MyYTdlOWUzMmFiYjIwNTFiMjQ4MWQwYmE3ZGVmZDYzNWNhN2E5MzMiCiAgICB9CiAgfQp9\" , // signature \"gaXuCCGyQ6465FS9kC0ylODMSV9aobFTqZuHsJlJhD1JbRQgYXzo5NdCHkKhu1GetmcDwueFYDRCN/KEMGCe79GOFgycdeOBcAxdiXRZg7mH2o8QR/5sIaD7yhrUKe+2Ji866j2gkPF7n4qWRSR5N+n66DxkO6S+/cb6J5CGYDUGZ6ywYKI2NkSg5Qn0O3bIvTbybl5n+y9Fcal4qyMOMBEpUSeNfkcmOn7SWawvXFY6o/1stHwVdNthF6dilsJSuNcMTnvsZ0vfFv9nzjf/Z1QF6aNF+BmucgTKT2idEOrh4hXIcRS+wrrC/jFGVXxcsSAkCS9cx7T5Nw2n5RNQMFFvJDkrHRLewagjD09J7C6E9LFBdWNWCxyWPueMN0kWdufsaFwAWCaOAdX2bh4E93Z2Y5dap+8gRiJAQBh4Z0QPuB97WpN2aptSBC6+q3jgmOd1LwefdHIm4sPktewdxTDewRULVY3ERTfxZB8WmX3hDHmHIlGufOhrDE7KI44BmnveQmRDFzMea+XUhQp3VXgnCLPf7W7rQ3+rluj1K9cAds/KPQIv0OjM+xlhZVRHWmcuISv7nEzoImblUc4WcUmhr7YxfZGrXLejc58/Dro95XK+AmNYmjcnZZry4yLmZEuba5UIYHEd9fdRSPwi/h3PyOBHUo2JMvc+TsgRaUU=\" ) ); I think that NPC's looking into your soul are not creepy at all, so let's make the NPC look at players and let's give it a name. 1 2 3 4 5 final NPC npc = ...; // you can totally do this in the npc builder, i chose not to, because i didn't want to copy the huge block of skin values npc . setShouldLookAtPlayer ( true ); // requires a List<Component> to allow for multiline names npc . setDisplayName ( Arrays . asList ( Component . text ( \"Misat11\" ))); And you've made yourself a fresh new NPC!","title":"Creating your first NPC"},{"location":"modules/plugin/","text":"Plugin \u00b6 Module required for generating platform plugin classes. Features \u00b6 List of all plugins Main class generation Plugin file (like plugin.yml) generation Usage \u00b6 Supported platforms are: bukkit, sponge, minestom, bungee, velocity Maven \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> plugin-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package --> Gradle \u00b6 1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:plugin-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' } Examples \u00b6 Making your first plugin \u00b6 Adventure If you're experiencing errors related to Adventure , make sure to relocate the net.kyori.adventure package! Creating the main plugin class \u00b6 Start with extending the PluginContainer class, like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class ExamplePlugin extends PluginContainer { @Override public void load () { // Plugin load logic } @Override public void enable () { // Plugin enable logic } @Override public void disable () { // Plugin disable logic } } After that, add the @Plugin and @Init (only if you use SLib services) annotations. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Plugin ( id = \"ExamplePlugin\" , name = \"ExamplePlugin\" , authors = { \"ScreamingSandals\" }, version = \"0.0.1-SNAPSHOT\" ) @Init ( services = { ExampleService . class }) public class ExamplePlugin extends PluginContainer { @Override public void load () { // Plugin load logic } @Override public void enable () { // Plugin enable logic } @Override public void disable () { // Plugin disable logic } } If you want to depend on some plugin(s), you can add the @PluginDependencies annotation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Plugin ( id = \"ExamplePlugin\" , name = \"ExamplePlugin\" , authors = { \"ScreamingSandals\" }, version = \"0.0.1-SNAPSHOT\" ) @PluginDependencies ( platform = PlatformType . BUKKIT , dependencies = { \"DependencyPlugin\" }, softDependencies = { \"SoftDependencyPlugin\" }, loadBefore = { \"LoadBeforePlugin\" }) @Init ( services = { ExampleService . class }) public class ExamplePlugin extends PluginContainer { @Override public void load () { // Plugin load logic } @Override public void enable () { // Plugin enable logic } @Override public void disable () { // Plugin disable logic } } And that's it!","title":"Plugin"},{"location":"modules/plugin/#plugin","text":"Module required for generating platform plugin classes.","title":"Plugin"},{"location":"modules/plugin/#features","text":"List of all plugins Main class generation Plugin file (like plugin.yml) generation","title":"Features"},{"location":"modules/plugin/#usage","text":"Supported platforms are: bukkit, sponge, minestom, bungee, velocity","title":"Usage"},{"location":"modules/plugin/#maven","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> plugin-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package -->","title":"Maven"},{"location":"modules/plugin/#gradle","text":"1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:plugin-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' }","title":"Gradle"},{"location":"modules/plugin/#examples","text":"","title":"Examples"},{"location":"modules/plugin/#making-your-first-plugin","text":"Adventure If you're experiencing errors related to Adventure , make sure to relocate the net.kyori.adventure package!","title":"Making your first plugin"},{"location":"modules/plugin/#creating-the-main-plugin-class","text":"Start with extending the PluginContainer class, like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class ExamplePlugin extends PluginContainer { @Override public void load () { // Plugin load logic } @Override public void enable () { // Plugin enable logic } @Override public void disable () { // Plugin disable logic } } After that, add the @Plugin and @Init (only if you use SLib services) annotations. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Plugin ( id = \"ExamplePlugin\" , name = \"ExamplePlugin\" , authors = { \"ScreamingSandals\" }, version = \"0.0.1-SNAPSHOT\" ) @Init ( services = { ExampleService . class }) public class ExamplePlugin extends PluginContainer { @Override public void load () { // Plugin load logic } @Override public void enable () { // Plugin enable logic } @Override public void disable () { // Plugin disable logic } } If you want to depend on some plugin(s), you can add the @PluginDependencies annotation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Plugin ( id = \"ExamplePlugin\" , name = \"ExamplePlugin\" , authors = { \"ScreamingSandals\" }, version = \"0.0.1-SNAPSHOT\" ) @PluginDependencies ( platform = PlatformType . BUKKIT , dependencies = { \"DependencyPlugin\" }, softDependencies = { \"SoftDependencyPlugin\" }, loadBefore = { \"LoadBeforePlugin\" }) @Init ( services = { ExampleService . class }) public class ExamplePlugin extends PluginContainer { @Override public void load () { // Plugin load logic } @Override public void enable () { // Plugin enable logic } @Override public void disable () { // Plugin disable logic } } And that's it!","title":"Creating the main plugin class"},{"location":"modules/tasker/","text":"Tasker \u00b6 A library required for creating synchronous and asynchronous tasks within the plugin. Features \u00b6 Self-cancelling tasks Asynchronous tasks Usage \u00b6 Supported platforms are: bukkit, bungee, minestom, sponge, velocity Maven \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> tasker-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package --> Gradle \u00b6 1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:tasker-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' } Examples \u00b6 Running tasks \u00b6 Start with registering the Tasker service class in your plugin's @Init annotation. 1 2 3 @Init ( services = { Tasker . class }) Normal task \u00b6 So let's say, that we want to create a task to send a message to console every 30 seconds until the server stops/plugin disables. First of all, let's create a task builder, which takes in a Runnable . 1 Tasker . build (() -> PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" )); Then, let's add the repeat time period. 1 Tasker . build (() -> PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" )). repeat ( 30 , TaskerTime . SECONDS ); Now let's start the task. 1 Tasker . build (() -> PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" )). repeat ( 30 , TaskerTime . SECONDS ). start (); And you're done! Self-cancelling task \u00b6 Let's create a task which sends a message to the console 10 times and then stops. First of all, let's create a task builder, which takes in a Function<TaskBase, Runnable> . 1 2 3 4 5 6 7 8 9 final AtomicInteger count = new AtomicInteger ( 0 ); Tasker . build ( taskBase -> () -> { if ( count . get () >= 10 ) { taskBase . cancel (); return ; } PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" ); count . getAndIncrement (); }); Then, let's run the task right away. 1 2 3 4 5 6 7 8 9 final AtomicInteger count = new AtomicInteger ( 0 ); Tasker . build ( taskBase -> () -> { if ( count . get () >= 10 ) { taskBase . cancel (); return ; } PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" ); count . getAndIncrement (); }). afterOneTick (). start (); Congrats, you've just made a self-cancelling task!","title":"Tasker"},{"location":"modules/tasker/#tasker","text":"A library required for creating synchronous and asynchronous tasks within the plugin.","title":"Tasker"},{"location":"modules/tasker/#features","text":"Self-cancelling tasks Asynchronous tasks","title":"Features"},{"location":"modules/tasker/#usage","text":"Supported platforms are: bukkit, bungee, minestom, sponge, velocity","title":"Usage"},{"location":"modules/tasker/#maven","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> tasker-YOUR_PLATFORM </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> 2.0.1-SNAPSHOT </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package -->","title":"Maven"},{"location":"modules/tasker/#gradle","text":"1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:tasker-YOUR_PLATFORM:2.0.1-SNAPSHOT' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:2.0.1-SNAPSHOT' }","title":"Gradle"},{"location":"modules/tasker/#examples","text":"","title":"Examples"},{"location":"modules/tasker/#running-tasks","text":"Start with registering the Tasker service class in your plugin's @Init annotation. 1 2 3 @Init ( services = { Tasker . class })","title":"Running tasks"},{"location":"modules/tasker/#normal-task","text":"So let's say, that we want to create a task to send a message to console every 30 seconds until the server stops/plugin disables. First of all, let's create a task builder, which takes in a Runnable . 1 Tasker . build (() -> PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" )); Then, let's add the repeat time period. 1 Tasker . build (() -> PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" )). repeat ( 30 , TaskerTime . SECONDS ); Now let's start the task. 1 Tasker . build (() -> PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" )). repeat ( 30 , TaskerTime . SECONDS ). start (); And you're done!","title":"Normal task"},{"location":"modules/tasker/#self-cancelling-task","text":"Let's create a task which sends a message to the console 10 times and then stops. First of all, let's create a task builder, which takes in a Function<TaskBase, Runnable> . 1 2 3 4 5 6 7 8 9 final AtomicInteger count = new AtomicInteger ( 0 ); Tasker . build ( taskBase -> () -> { if ( count . get () >= 10 ) { taskBase . cancel (); return ; } PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" ); count . getAndIncrement (); }); Then, let's run the task right away. 1 2 3 4 5 6 7 8 9 final AtomicInteger count = new AtomicInteger ( 0 ); Tasker . build ( taskBase -> () -> { if ( count . get () >= 10 ) { taskBase . cancel (); return ; } PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" ); count . getAndIncrement (); }). afterOneTick (). start (); Congrats, you've just made a self-cancelling task!","title":"Self-cancelling task"}]}