{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 ScreamingLib is a multiplatform library for creating Minecraft plugins/extensions. Module list \u00b6 Modules for servers \u00b6 Core Tasker Event Hologram Health indicator Lang NPC Packets for the Minecraft: Java Edition Placeholders Command Scoreboards and sidebars Clickable signs Modules for proxy \u00b6 Core Tasker Event Lang Command Compiling \u00b6 Requirements \u00b6 JDK 11 and higher Internet connection Clone the repo and run ./gradlew screamCompile . Binaries for each module will be present in the build/libs folder of each subproject and also in your local maven repository.","title":"Home"},{"location":"#home","text":"ScreamingLib is a multiplatform library for creating Minecraft plugins/extensions.","title":"Home"},{"location":"#module-list","text":"","title":"Module list"},{"location":"#modules-for-servers","text":"Core Tasker Event Hologram Health indicator Lang NPC Packets for the Minecraft: Java Edition Placeholders Command Scoreboards and sidebars Clickable signs","title":"Modules for servers"},{"location":"#modules-for-proxy","text":"Core Tasker Event Lang Command","title":"Modules for proxy"},{"location":"#compiling","text":"","title":"Compiling"},{"location":"#requirements","text":"JDK 11 and higher Internet connection Clone the repo and run ./gradlew screamCompile . Binaries for each module will be present in the build/libs folder of each subproject and also in your local maven repository.","title":"Requirements"},{"location":"examples/","text":"Examples \u00b6 Making your first plugin \u00b6 Adventure If you're experiencing errors related to Adventure , make sure to relocate the net.kyori.adventure package! Creating the main plugin class \u00b6 Dependencies Make sure to get the core , plugin and screaming-annotation module dependencies! Start with extending the PluginContainer class, like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class ExamplePlugin extends PluginContainer { @Override public void load () { // Plugin load logic } @Override public void enable () { // Plugin enable logic } @Override public void disable () { // Plugin disable logic } } After that, add the @Plugin and @Init (only if you use SLib services) annotations. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Plugin ( id = \"ExamplePlugin\" , name = \"ExamplePlugin\" , authors = { \"ScreamingSandals\" }, version = \"0.0.1-SNAPSHOT\" ) @Init ( services = { ExampleService . class }) public class ExamplePlugin extends PluginContainer { @Override public void load () { // Plugin load logic } @Override public void enable () { // Plugin enable logic } @Override public void disable () { // Plugin disable logic } } If you want to depend on some plugin(s), you can add the @PluginDependencies annotation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Plugin ( id = \"ExamplePlugin\" , name = \"ExamplePlugin\" , authors = { \"ScreamingSandals\" }, version = \"0.0.1-SNAPSHOT\" ) @PluginDependencies ( platform = PlatformType . BUKKIT , dependencies = { \"DependencyPlugin\" }, softDependencies = { \"SoftDependencyPlugin\" }, loadBefore = { \"LoadBeforePlugin\" }) @Init ( services = { ExampleService . class }) public class ExamplePlugin extends PluginContainer { @Override public void load () { // Plugin load logic } @Override public void enable () { // Plugin enable logic } @Override public void disable () { // Plugin disable logic } } And that's it! Handling game events \u00b6 Dependencies Make sure to get the event module dependency! First of all, start by making a simple service class, like this: 1 2 3 4 @Service public class ExampleService { // Service class } Then create a new public method that returns void, has an event parameter and annotate it with @OnEvent . It is possible to specify the priority field and the ignoreCancelled field in the annotation. 1 2 3 4 5 6 7 @Service public class ExampleService { @OnEvent ( priority = EventPriority . HIGHEST , ignoreCancelled = true ) public void onPlayerInteract ( SPlayerInteractEvent event ) { // Event handling logic } } Then register the service class in the @Init annotation on the main plugin class, and you're done! Running tasks with Tasker \u00b6 Dependencies Make sure to get the tasker module dependency! Start with registering the Tasker service class in your plugin's @Init annotation. 1 2 3 @Init ( services = { Tasker . class }) Normal task \u00b6 So let's say, that we want to create a task to send a message to console every 30 seconds until the server stops/plugin disables. First of all, let's create a task builder, which takes in a Runnable . 1 Tasker . build (() -> PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" )); Then, let's add the repeat time period. 1 Tasker . build (() -> PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" )). repeat ( 30 , TaskerTime . SECONDS ); Now let's start the task. 1 Tasker . build (() -> PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" )). repeat ( 30 , TaskerTime . SECONDS ). start (); And you're done! Self-cancelling task \u00b6 Let's create a task which sends a message to the console 10 times and then stops. First of all, let's create a task builder, which takes in a Function<TaskBase, Runnable> . 1 2 3 4 5 6 7 8 9 final AtomicInteger count = new AtomicInteger ( 0 ); Tasker . build ( taskBase -> () -> { if ( count . get () >= 10 ) { taskBase . cancel (); return ; } PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" ); count . getAndIncrement (); }); Then, let's run the task right away. 1 2 3 4 5 6 7 8 9 final AtomicInteger count = new AtomicInteger ( 0 ); Tasker . build ( taskBase -> () -> { if ( count . get () >= 10 ) { taskBase . cancel (); return ; } PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" ); count . getAndIncrement (); }). afterOneTick (). start (); Congrats, you've just made a self-cancelling task! Creating commands with Cloud \u00b6 Dependencies Make sure to get the command (and cloud-minecraft-extras, optional) module dependency! Command service \u00b6 Let's start with creating a service that will construct all of our commands (feel free to copy paste the snippet). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Service ( dependsOn = { CloudConstructor . class }) public final class CommandService { @Provider ( level = Provider . Level . POST_ENABLE ) public static CommandManager < CommandSenderWrapper > provideCommandManager () { try { final CommandManager < CommandSenderWrapper > manager = CloudConstructor . construct ( CommandExecutionCoordinator . simpleCoordinator ()); // provides a central place for handling common command usage errors // remove this part if you don't have the cloud-minecraft-extras module new MinecraftExceptionHandler < CommandSenderWrapper > () . withDefaultHandlers () . withHandler ( MinecraftExceptionHandler . ExceptionType . NO_PERMISSION , ( senderWrapper , e ) -> // Component from Adventure Component . text ( \"Insufficient permissions!\" ) ) . withHandler ( MinecraftExceptionHandler . ExceptionType . INVALID_SYNTAX , ( senderWrapper , e ) -> // Component from Adventure Component . text ( \"Invalid syntax!\" ) ) . apply ( manager , s -> s ); return manager ; } catch ( Exception e ) { e . printStackTrace (); } return null ; } } Base command class \u00b6 Then, create an abstract class that will be extended by the command classes (feel free to copy paste the snippet). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @ServiceDependencies ( dependsOn = { CommandService . class // the command service class you created in the last step }) public abstract class BaseCommand { protected final @NonNull String name ; protected final @Nullable Permission permission ; protected final boolean allowConsole ; public BaseCommand ( String name , Permission permission , boolean allowConsole ) { this . name = name ; this . permission = permission ; this . allowConsole = allowConsole ; } public @NonNull String getName () { return name ; } public @Nullable Permission getPermission () { return permission ; } public boolean isConsoleAllowed () { return allowConsole ; } protected abstract void construct ( Command . Builder < CommandSenderWrapper > commandSenderWrapperBuilder , CommandManager < CommandSenderWrapper > manager ); @OnPostEnable public void construct ( @ProvidedBy ( CommandService . class ) CommandManager < CommandSenderWrapper > manager ) { // all commands will have the same root, e.g. /someplugin <command name> Command . Builder < CommandSenderWrapper > builder = manager . commandBuilder ( \"someplugin\" ) . literal ( name ); // or you can have separated commands // Command.Builder<CommandSenderWrapper> builder = manager.commandBuilder(name); // checks for permissions if ( permission != null ) { builder = builder . permission ( PredicatePermission . of ( SimpleCloudKey . of ( name ), perm -> perm . getType () == CommandSenderWrapper . Type . CONSOLE || permission . hasPermission ( perm ) ) ); } // sender will be directly PlayerWrapper, if console is not allowed if ( ! allowConsole ) { builder = builder . senderType ( PlayerWrapper . class ); } construct ( builder , manager ); } } Command implementation \u00b6 Now let's actually implement the command. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Service public class ExampleCommand extends BaseCommand { // extend the base command class that we created in the last step public BanCommand () { // command name, command permission (can be null for no permission), is console allowed? super ( \"examplecommand\" , null , true ); } @Override protected void construct ( Command . Builder < CommandSenderWrapper > commandSenderWrapperBuilder , CommandManager < CommandSenderWrapper > manager ) { manager . command ( commandSenderWrapperBuilder // PlayerWrapper argument . argument ( manager . argumentBuilder ( String . class , \"player\" ) . withSuggestionsProvider (( c , s ) -> Server . getConnectedPlayers (). stream (). map ( PlayerWrapper :: getName ). toList () ) ) . handler ( commandContext -> { final Optional < PlayerWrapper > player = PlayerMapper . getPlayer (( String ) commandContext . get ( \"player\" )); if ( player . isEmpty ()) { commandContext . getSender (). sendMessage ( \"Invalid player specified!\" ); return ; } final String senderName = ( commandContext . getSender (). getType () == CommandSenderWrapper . Type . CONSOLE ) ? \"CONSOLE\" : commandContext . getSender (). as ( PlayerWrapper . class ). getName (); player . orElseThrow (). sendMessage ( \"Hello from \" + senderName ); }) ); } } Now register the command implementation class in your plugin's @Init annotation, and you're done! You've just made yourself a command in the /someplugin examplecommand <player> format.","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#making-your-first-plugin","text":"Adventure If you're experiencing errors related to Adventure , make sure to relocate the net.kyori.adventure package!","title":"Making your first plugin"},{"location":"examples/#creating-the-main-plugin-class","text":"Dependencies Make sure to get the core , plugin and screaming-annotation module dependencies! Start with extending the PluginContainer class, like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class ExamplePlugin extends PluginContainer { @Override public void load () { // Plugin load logic } @Override public void enable () { // Plugin enable logic } @Override public void disable () { // Plugin disable logic } } After that, add the @Plugin and @Init (only if you use SLib services) annotations. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Plugin ( id = \"ExamplePlugin\" , name = \"ExamplePlugin\" , authors = { \"ScreamingSandals\" }, version = \"0.0.1-SNAPSHOT\" ) @Init ( services = { ExampleService . class }) public class ExamplePlugin extends PluginContainer { @Override public void load () { // Plugin load logic } @Override public void enable () { // Plugin enable logic } @Override public void disable () { // Plugin disable logic } } If you want to depend on some plugin(s), you can add the @PluginDependencies annotation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Plugin ( id = \"ExamplePlugin\" , name = \"ExamplePlugin\" , authors = { \"ScreamingSandals\" }, version = \"0.0.1-SNAPSHOT\" ) @PluginDependencies ( platform = PlatformType . BUKKIT , dependencies = { \"DependencyPlugin\" }, softDependencies = { \"SoftDependencyPlugin\" }, loadBefore = { \"LoadBeforePlugin\" }) @Init ( services = { ExampleService . class }) public class ExamplePlugin extends PluginContainer { @Override public void load () { // Plugin load logic } @Override public void enable () { // Plugin enable logic } @Override public void disable () { // Plugin disable logic } } And that's it!","title":"Creating the main plugin class"},{"location":"examples/#handling-game-events","text":"Dependencies Make sure to get the event module dependency! First of all, start by making a simple service class, like this: 1 2 3 4 @Service public class ExampleService { // Service class } Then create a new public method that returns void, has an event parameter and annotate it with @OnEvent . It is possible to specify the priority field and the ignoreCancelled field in the annotation. 1 2 3 4 5 6 7 @Service public class ExampleService { @OnEvent ( priority = EventPriority . HIGHEST , ignoreCancelled = true ) public void onPlayerInteract ( SPlayerInteractEvent event ) { // Event handling logic } } Then register the service class in the @Init annotation on the main plugin class, and you're done!","title":"Handling game events"},{"location":"examples/#running-tasks-with-tasker","text":"Dependencies Make sure to get the tasker module dependency! Start with registering the Tasker service class in your plugin's @Init annotation. 1 2 3 @Init ( services = { Tasker . class })","title":"Running tasks with Tasker"},{"location":"examples/#normal-task","text":"So let's say, that we want to create a task to send a message to console every 30 seconds until the server stops/plugin disables. First of all, let's create a task builder, which takes in a Runnable . 1 Tasker . build (() -> PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" )); Then, let's add the repeat time period. 1 Tasker . build (() -> PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" )). repeat ( 30 , TaskerTime . SECONDS ); Now let's start the task. 1 Tasker . build (() -> PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" )). repeat ( 30 , TaskerTime . SECONDS ). start (); And you're done!","title":"Normal task"},{"location":"examples/#self-cancelling-task","text":"Let's create a task which sends a message to the console 10 times and then stops. First of all, let's create a task builder, which takes in a Function<TaskBase, Runnable> . 1 2 3 4 5 6 7 8 9 final AtomicInteger count = new AtomicInteger ( 0 ); Tasker . build ( taskBase -> () -> { if ( count . get () >= 10 ) { taskBase . cancel (); return ; } PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" ); count . getAndIncrement (); }); Then, let's run the task right away. 1 2 3 4 5 6 7 8 9 final AtomicInteger count = new AtomicInteger ( 0 ); Tasker . build ( taskBase -> () -> { if ( count . get () >= 10 ) { taskBase . cancel (); return ; } PlayerMapper . getConsoleSender (). sendMessage ( \"Hello World!\" ); count . getAndIncrement (); }). afterOneTick (). start (); Congrats, you've just made a self-cancelling task!","title":"Self-cancelling task"},{"location":"examples/#creating-commands-with-cloud","text":"Dependencies Make sure to get the command (and cloud-minecraft-extras, optional) module dependency!","title":"Creating commands with Cloud"},{"location":"examples/#command-service","text":"Let's start with creating a service that will construct all of our commands (feel free to copy paste the snippet). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Service ( dependsOn = { CloudConstructor . class }) public final class CommandService { @Provider ( level = Provider . Level . POST_ENABLE ) public static CommandManager < CommandSenderWrapper > provideCommandManager () { try { final CommandManager < CommandSenderWrapper > manager = CloudConstructor . construct ( CommandExecutionCoordinator . simpleCoordinator ()); // provides a central place for handling common command usage errors // remove this part if you don't have the cloud-minecraft-extras module new MinecraftExceptionHandler < CommandSenderWrapper > () . withDefaultHandlers () . withHandler ( MinecraftExceptionHandler . ExceptionType . NO_PERMISSION , ( senderWrapper , e ) -> // Component from Adventure Component . text ( \"Insufficient permissions!\" ) ) . withHandler ( MinecraftExceptionHandler . ExceptionType . INVALID_SYNTAX , ( senderWrapper , e ) -> // Component from Adventure Component . text ( \"Invalid syntax!\" ) ) . apply ( manager , s -> s ); return manager ; } catch ( Exception e ) { e . printStackTrace (); } return null ; } }","title":"Command service"},{"location":"examples/#base-command-class","text":"Then, create an abstract class that will be extended by the command classes (feel free to copy paste the snippet). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @ServiceDependencies ( dependsOn = { CommandService . class // the command service class you created in the last step }) public abstract class BaseCommand { protected final @NonNull String name ; protected final @Nullable Permission permission ; protected final boolean allowConsole ; public BaseCommand ( String name , Permission permission , boolean allowConsole ) { this . name = name ; this . permission = permission ; this . allowConsole = allowConsole ; } public @NonNull String getName () { return name ; } public @Nullable Permission getPermission () { return permission ; } public boolean isConsoleAllowed () { return allowConsole ; } protected abstract void construct ( Command . Builder < CommandSenderWrapper > commandSenderWrapperBuilder , CommandManager < CommandSenderWrapper > manager ); @OnPostEnable public void construct ( @ProvidedBy ( CommandService . class ) CommandManager < CommandSenderWrapper > manager ) { // all commands will have the same root, e.g. /someplugin <command name> Command . Builder < CommandSenderWrapper > builder = manager . commandBuilder ( \"someplugin\" ) . literal ( name ); // or you can have separated commands // Command.Builder<CommandSenderWrapper> builder = manager.commandBuilder(name); // checks for permissions if ( permission != null ) { builder = builder . permission ( PredicatePermission . of ( SimpleCloudKey . of ( name ), perm -> perm . getType () == CommandSenderWrapper . Type . CONSOLE || permission . hasPermission ( perm ) ) ); } // sender will be directly PlayerWrapper, if console is not allowed if ( ! allowConsole ) { builder = builder . senderType ( PlayerWrapper . class ); } construct ( builder , manager ); } }","title":"Base command class"},{"location":"examples/#command-implementation","text":"Now let's actually implement the command. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Service public class ExampleCommand extends BaseCommand { // extend the base command class that we created in the last step public BanCommand () { // command name, command permission (can be null for no permission), is console allowed? super ( \"examplecommand\" , null , true ); } @Override protected void construct ( Command . Builder < CommandSenderWrapper > commandSenderWrapperBuilder , CommandManager < CommandSenderWrapper > manager ) { manager . command ( commandSenderWrapperBuilder // PlayerWrapper argument . argument ( manager . argumentBuilder ( String . class , \"player\" ) . withSuggestionsProvider (( c , s ) -> Server . getConnectedPlayers (). stream (). map ( PlayerWrapper :: getName ). toList () ) ) . handler ( commandContext -> { final Optional < PlayerWrapper > player = PlayerMapper . getPlayer (( String ) commandContext . get ( \"player\" )); if ( player . isEmpty ()) { commandContext . getSender (). sendMessage ( \"Invalid player specified!\" ); return ; } final String senderName = ( commandContext . getSender (). getType () == CommandSenderWrapper . Type . CONSOLE ) ? \"CONSOLE\" : commandContext . getSender (). as ( PlayerWrapper . class ). getName (); player . orElseThrow (). sendMessage ( \"Hello from \" + senderName ); }) ); } } Now register the command implementation class in your plugin's @Init annotation, and you're done! You've just made yourself a command in the /someplugin examplecommand <player> format.","title":"Command implementation"},{"location":"modules/command/","text":"Command \u00b6 Module required for creating multi-platform commands. Features \u00b6 Cloud Command Framework integration Usage \u00b6 Supported platforms are: bukkit, bungee, minestom, sponge, velocity Maven \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> command-YOUR_PLATFORM </artifactId> <version> LATEST_VERSION </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> LATEST_VERSION </version> <scope> provided </scope> </dependency> <!-- Optional, but recommended (change version to the latest if necessary) --> <!-- https://mvnrepository.com/artifact/cloud.commandframework/cloud-minecraft-extras --> <dependency> <groupId> cloud.commandframework </groupId> <artifactId> cloud-minecraft-extras </artifactId> <version> 1.5.0 </version> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package --> Gradle \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:command-YOUR_PLATFORM:LATEST_VERSION_HERE' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:LATEST_VERSION_HERE' // Optional, but recommended (change the version to the latest if necessary) // https://mvnrepository.com/artifact/cloud.commandframework/cloud-minecraft-extras implementation 'cloud.commandframework:cloud-minecraft-extras:1.5.0' }","title":"Command"},{"location":"modules/command/#command","text":"Module required for creating multi-platform commands.","title":"Command"},{"location":"modules/command/#features","text":"Cloud Command Framework integration","title":"Features"},{"location":"modules/command/#usage","text":"Supported platforms are: bukkit, bungee, minestom, sponge, velocity","title":"Usage"},{"location":"modules/command/#maven","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> command-YOUR_PLATFORM </artifactId> <version> LATEST_VERSION </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> LATEST_VERSION </version> <scope> provided </scope> </dependency> <!-- Optional, but recommended (change version to the latest if necessary) --> <!-- https://mvnrepository.com/artifact/cloud.commandframework/cloud-minecraft-extras --> <dependency> <groupId> cloud.commandframework </groupId> <artifactId> cloud-minecraft-extras </artifactId> <version> 1.5.0 </version> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package -->","title":"Maven"},{"location":"modules/command/#gradle","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:command-YOUR_PLATFORM:LATEST_VERSION_HERE' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:LATEST_VERSION_HERE' // Optional, but recommended (change the version to the latest if necessary) // https://mvnrepository.com/artifact/cloud.commandframework/cloud-minecraft-extras implementation 'cloud.commandframework:cloud-minecraft-extras:1.5.0' }","title":"Gradle"},{"location":"modules/core/","text":"Core \u00b6 Base module required for pretty much everything in SLib. Contains the base features for working with the server, such as the item API, block API, entities API and more. All other modules require this module to be present. Platform support \u00b6 Minecraft: Java Edition <1.9.4 1.9.4 1.10.x 1.11.x 1.12.x 1.13.x 1.14.x 1.15.x 1.16.x 1.17.x Spigot / Paper (and forks) No Yes Yes Yes Yes Yes Yes Yes Yes Yes Glowstone No ? ? ? ? ? MohistMC (and similar) No ? ? ? Minestom No Planned Sponge API 8+ Planned Planned ? = the version may be supported, but the current state is unknown Empty field = there's no such version of the specific platform Support for the Bedrock Edition is also planned, but not anytime soon. Minecraft: Bedrock Edition Latest Nukkit Planned Cloudburst Planned Usage \u00b6 Supported platforms are: bukkit, minestom, sponge Maven \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> core-YOUR_PLATFORM </artifactId> <version> LATEST_VERSION </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> LATEST_VERSION </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package --> Gradle \u00b6 1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:core-YOUR_PLATFORM:LATEST_VERSION_HERE' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:LATEST_VERSION_HERE' } Comparison to the Bukkit API \u00b6 Bukkit API class SLib class Player PlayerWrapper HumanEntity EntityHuman LivingEntity EntityLiving Projectile EntityProjectile Item EntityItem ExperienceOrb EntityExperience LightningStrike EntityLightning Firework EntityFirework Entity EntityBasic World WorldHolder Location LocationHolder Block BlockHolder Material ItemTypeHolder (for item materials), BlockTypeHolder (for block materials) Server Server ItemStack Item Services \u00b6 Services are classes with the @Service annotation, specified in the @Init annotation on the main plugin class. They are initialized when the plugin starts to load. It is possible to retrieve the service class instances with the ServiceManager class ( ServiceManager#get(Class<?>) ). Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Service ( dependsOn = { SomeExampleServiceThatThisDependsOn . class }, loadAfter = { SomeExampleServiceThatWillBeLoadedBeforeThis . class }) public class ExampleService { @OnPostConstruct public void onConstruct () { // Service construction logic } @OnEnable public void enable () { // Service enable logic } @OnDisable public void disable () { // Service disable logic (plugin is disabling) } } Annotations \u00b6 @Service(dependsOn = {}, loadAfter = {}) - Marks the annotated class as a service. Service classes specified in the dependsOn field are loaded before initializing the annotated class, while service classes specified in the loadAfter field are loaded after initializing the annotated class. @OnPostConstruct - Marks the annotated method to run directly after the service class is constructed. @OnEnable - Marks the annotated method to run after the service class is initialized. @OnDisable - Marks the annotated method to run after the service class is being disabled (plugin is disabling). @Init(platforms = {}, services = {}) (plugin class only) - Defines service classes that should be initialized when the plugin is loading (order sensitive). In the platforms field, you can specify platforms that the service classes in the annotation will be initialized on (array of PlatformType , can be left out).","title":"Core"},{"location":"modules/core/#core","text":"Base module required for pretty much everything in SLib. Contains the base features for working with the server, such as the item API, block API, entities API and more. All other modules require this module to be present.","title":"Core"},{"location":"modules/core/#platform-support","text":"Minecraft: Java Edition <1.9.4 1.9.4 1.10.x 1.11.x 1.12.x 1.13.x 1.14.x 1.15.x 1.16.x 1.17.x Spigot / Paper (and forks) No Yes Yes Yes Yes Yes Yes Yes Yes Yes Glowstone No ? ? ? ? ? MohistMC (and similar) No ? ? ? Minestom No Planned Sponge API 8+ Planned Planned ? = the version may be supported, but the current state is unknown Empty field = there's no such version of the specific platform Support for the Bedrock Edition is also planned, but not anytime soon. Minecraft: Bedrock Edition Latest Nukkit Planned Cloudburst Planned","title":"Platform support"},{"location":"modules/core/#usage","text":"Supported platforms are: bukkit, minestom, sponge","title":"Usage"},{"location":"modules/core/#maven","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> core-YOUR_PLATFORM </artifactId> <version> LATEST_VERSION </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> LATEST_VERSION </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package -->","title":"Maven"},{"location":"modules/core/#gradle","text":"1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:core-YOUR_PLATFORM:LATEST_VERSION_HERE' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:LATEST_VERSION_HERE' }","title":"Gradle"},{"location":"modules/core/#comparison-to-the-bukkit-api","text":"Bukkit API class SLib class Player PlayerWrapper HumanEntity EntityHuman LivingEntity EntityLiving Projectile EntityProjectile Item EntityItem ExperienceOrb EntityExperience LightningStrike EntityLightning Firework EntityFirework Entity EntityBasic World WorldHolder Location LocationHolder Block BlockHolder Material ItemTypeHolder (for item materials), BlockTypeHolder (for block materials) Server Server ItemStack Item","title":"Comparison to the Bukkit API"},{"location":"modules/core/#services","text":"Services are classes with the @Service annotation, specified in the @Init annotation on the main plugin class. They are initialized when the plugin starts to load. It is possible to retrieve the service class instances with the ServiceManager class ( ServiceManager#get(Class<?>) ). Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Service ( dependsOn = { SomeExampleServiceThatThisDependsOn . class }, loadAfter = { SomeExampleServiceThatWillBeLoadedBeforeThis . class }) public class ExampleService { @OnPostConstruct public void onConstruct () { // Service construction logic } @OnEnable public void enable () { // Service enable logic } @OnDisable public void disable () { // Service disable logic (plugin is disabling) } }","title":"Services"},{"location":"modules/core/#annotations","text":"@Service(dependsOn = {}, loadAfter = {}) - Marks the annotated class as a service. Service classes specified in the dependsOn field are loaded before initializing the annotated class, while service classes specified in the loadAfter field are loaded after initializing the annotated class. @OnPostConstruct - Marks the annotated method to run directly after the service class is constructed. @OnEnable - Marks the annotated method to run after the service class is initialized. @OnDisable - Marks the annotated method to run after the service class is being disabled (plugin is disabling). @Init(platforms = {}, services = {}) (plugin class only) - Defines service classes that should be initialized when the plugin is loading (order sensitive). In the platforms field, you can specify platforms that the service classes in the annotation will be initialized on (array of PlatformType , can be left out).","title":"Annotations"},{"location":"modules/event/","text":"Event \u00b6 Module required for handling game events. Features \u00b6 Event priorities. Ignoring cancellation. Usage \u00b6 Supported platforms are: bukkit, sponge, bungee, velocity Maven \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> event-YOUR_PLATFORM </artifactId> <version> LATEST_VERSION </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> LATEST_VERSION </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package --> Gradle \u00b6 1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:event-YOUR_PLATFORM:LATEST_VERSION_HERE' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:LATEST_VERSION_HERE' }","title":"Event"},{"location":"modules/event/#event","text":"Module required for handling game events.","title":"Event"},{"location":"modules/event/#features","text":"Event priorities. Ignoring cancellation.","title":"Features"},{"location":"modules/event/#usage","text":"Supported platforms are: bukkit, sponge, bungee, velocity","title":"Usage"},{"location":"modules/event/#maven","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> event-YOUR_PLATFORM </artifactId> <version> LATEST_VERSION </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> LATEST_VERSION </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package -->","title":"Maven"},{"location":"modules/event/#gradle","text":"1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:event-YOUR_PLATFORM:LATEST_VERSION_HERE' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:LATEST_VERSION_HERE' }","title":"Gradle"},{"location":"modules/plugin/","text":"Plugin \u00b6 Module required for generating platform plugin classes. Features \u00b6 List of all plugins. Main classes generation. Plugin files (like plugin.yml) generation. Usage \u00b6 Supported platforms are: bukkit, sponge, minestom, bungee, velocity Maven \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> plugin-YOUR_PLATFORM </artifactId> <version> LATEST_VERSION </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> LATEST_VERSION </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package --> Gradle \u00b6 1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:plugin-YOUR_PLATFORM:LATEST_VERSION_HERE' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:LATEST_VERSION_HERE' }","title":"Plugin"},{"location":"modules/plugin/#plugin","text":"Module required for generating platform plugin classes.","title":"Plugin"},{"location":"modules/plugin/#features","text":"List of all plugins. Main classes generation. Plugin files (like plugin.yml) generation.","title":"Features"},{"location":"modules/plugin/#usage","text":"Supported platforms are: bukkit, sponge, minestom, bungee, velocity","title":"Usage"},{"location":"modules/plugin/#maven","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> plugin-YOUR_PLATFORM </artifactId> <version> LATEST_VERSION </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> LATEST_VERSION </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package -->","title":"Maven"},{"location":"modules/plugin/#gradle","text":"1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:plugin-YOUR_PLATFORM:LATEST_VERSION_HERE' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:LATEST_VERSION_HERE' }","title":"Gradle"},{"location":"modules/tasker/","text":"Tasker \u00b6 A library required for creating synchronous and asynchronous tasks within the plugin. Features \u00b6 Self-cancelling tasks. Asynchronous tasks. Usage \u00b6 Supported platforms are: bukkit, bungee, minestom, sponge, velocity Maven \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> tasker-YOUR_PLATFORM </artifactId> <version> LATEST_VERSION </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> LATEST_VERSION </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package --> Gradle \u00b6 1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:tasker-YOUR_PLATFORM:LATEST_VERSION_HERE' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:LATEST_VERSION_HERE' }","title":"Tasker"},{"location":"modules/tasker/#tasker","text":"A library required for creating synchronous and asynchronous tasks within the plugin.","title":"Tasker"},{"location":"modules/tasker/#features","text":"Self-cancelling tasks. Asynchronous tasks.","title":"Features"},{"location":"modules/tasker/#usage","text":"Supported platforms are: bukkit, bungee, minestom, sponge, velocity","title":"Usage"},{"location":"modules/tasker/#maven","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <repositories> <repository> <id> screamingrepo </id> <url> https://repo.screamingsandals.org/repository/maven-public </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> tasker-YOUR_PLATFORM </artifactId> <version> LATEST_VERSION </version> <scope> compile </scope> </dependency> <dependency> <groupId> org.screamingsandals.lib </groupId> <artifactId> screaming-annotation </artifactId> <version> LATEST_VERSION </version> <scope> provided </scope> </dependency> </dependencies> <!-- Shade plugin configuration and relocation package org.screamingsandals.lib to your own package -->","title":"Maven"},{"location":"modules/tasker/#gradle","text":"1 2 3 4 5 6 7 8 9 10 repositories { maven { url 'https://repo.screamingsandals.org/repository/maven-public' } } dependencies { implementation 'org.screamingsandals.lib:tasker-YOUR_PLATFORM:LATEST_VERSION_HERE' annotationProcessor 'org.screamingsandals.lib:screaming-annotation:LATEST_VERSION_HERE' }","title":"Gradle"}]}